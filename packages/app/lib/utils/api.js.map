{"version":3,"sources":["../../src/utils/api.js"],"names":["request","options","dispatch","getState","_request","state","community","active","query","params","getDataFromClient","uri","constructUri","queryString","queryParams","fetch","method","reqOptions","body","response","handleErrors","responseOk","json","rootUrl","API_URL","apiPath","endpoint","match","path","Object","keys","reduce","a","key","storage","getToken","token","credentials","headers","Accept","Authorization","paramString","filter","p","map","k","encodeURIComponent","join","length","ok","error","statusText","message","Error"],"mappings":"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","sourcesContent":["import * as storage from './storage';\n\nimport { API_URL } from './env';\n// const routes = {};\n// const IS_SERVER = !process.env.BROWSER && process.env.WEB === 'true';\n// const IS_CLIENT = !IS_SERVER;\n\n// if (IS_CLIENT) {\n//   // this is a weird hack that makes conditional require work in react-native\n// } else {\n//   // Desktop ONLY!!!\n//   // use react-native field in package.json\n//   // this will prevent react native from loading these modules\n//   const postApi = '../../server/api/post/post.controller';\n//   const userApi = '../../server/api/user/user.controller';\n//   const commentsApi = '../../server/api/comment/comment.controller';\n//   const feedApi = '../../server/api/communityFeed/communityFeed.controller';\n//   const communityApi = '../../server/api/community/community.controller';\n\n//   routes.comment = require(commentsApi) || {}; // eslint-disable-line\n//   routes.communityFeed = require(feedApi) || {}; // eslint-disable-line\n//   routes.post = require(postApi) || {}; // eslint-disable-line\n//   routes.user = require(userApi) || {}; // eslint-disable-line\n//   routes.community = require(communityApi) || {}; // eslint-disable-line\n// }\n\nexport const request = options => (dispatch, getState) => _request(options, getState);\n\n/**\n * send request to api\n * @param  {[type]} options\n * query - Object of url query params\n * params - url params\n * endpoint - api endpoint (user / post etc)\n * path - speicifi api call (default is index)\n * uri - optional - custom url\n * method - REST method\n * body: body\n */\nexport async function _request(options, getState) {\n  // Add community query parameter\n  const state = getState();\n  const community = state.community.active;\n  const query = community ? { community, ...options.query } : { ...options.query };\n  const params = { ...options, query };\n\n  // ---------------------------------------------\n  // This is the case when request is orginating from nodejs\n  // ---------------------------------------------\n  // if (IS_SERVER) return getDataOnServer(params);\n\n  // ---------------------------------------------\n  // This is the case when request is orginating from client\n  // ---------------------------------------------\n  return getDataFromClient(params);\n}\n\nasync function getDataFromClient(params) {\n  const uri = constructUri(params);\n  const queryString = queryParams(params.query);\n  const response = await fetch(uri + queryString, {\n    method: params.method,\n    ...(await reqOptions()),\n    body: params.body\n  });\n  const responseOk = await handleErrors(response);\n  return responseOk.json();\n}\n\n// async function getDataOnServer(params) {\n//   const path = params.path || '';\n//   if (path === '') params.path = 'index';\n//   const req = {\n//     params: params.params,\n//     body: params.body,\n//     query: params.query,\n//     user: params.user,\n//   };\n//   const next = () => null;\n//   const res = null;\n//   if (!routes[params.endpoint] || !routes[params.endpoint][params.path]) {\n//     return null;\n//   }\n//   const resJSON = await routes[params.endpoint][params.path](req, res, next);\n\n//   // convert to object in case we get a mongoose object back\n//   return resJSON && resJSON.toObject ? resJSON.toObject() : resJSON;\n// }\n\nfunction constructUri(options) {\n  const rootUrl = options.uri || API_URL;\n  const apiPath = options.endpoint.match('auth') ? '' : '/api/';\n  const path = options.path || '';\n  const params = options.params\n    ? Object.keys(options.params).reduce((a, key) => a + '/' + options.params[key], '')\n    : '';\n  return rootUrl + apiPath + options.endpoint + path + params;\n}\n\nexport async function reqOptions() {\n  try {\n    const token = await storage.getToken();\n    return {\n      credentials: 'include',\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${token}`\n      }\n    };\n  } catch (err) {\n    return {\n      credentials: 'include',\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n      }\n    };\n  }\n}\n\nexport const queryParams = params => {\n  if (!params) return '';\n  const paramString = Object.keys(params)\n    .filter(p => params[p])\n    .map(k => encodeURIComponent(k) + '=' + encodeURIComponent(params[k]))\n    .join('&');\n  if (paramString && paramString.length) return '?' + paramString;\n  return '';\n};\n\nexport async function handleErrors(response) {\n  if (!response.ok) {\n    let error = response.statusText;\n    try {\n      const json = await response.json();\n      if (json) {\n        error = json.message;\n        throw Error(error);\n      }\n    } catch (err) {\n      throw Error(error);\n    }\n  }\n  return response;\n}\n"],"file":"api.js"}